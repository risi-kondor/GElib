**********************
SO3bipart/SO3bipartArr
**********************

An ``SO3bipart`` object is similar to an ``SO3part``, except it has two separate :math:`SO3` covariant indices, 
possibly corresponding to possbily two different irreps of :math:`SO3`. 
Hence, an ``SO3bipart`` with batch dimension ``b`` and channel dimension ``n`` corresponding to the ``l1`` and 
``l2`` irreps is a ``(b,2l1+1,2l2+1,n)`` dimensional single precision complex ``torch.Tensor``.
Just like an ``SO3part``, an ``SO3bipart`` object can be constructed directly from a PyTorch tensor, or 
via its ``zeros`` or ``randn`` constructors, for example:

.. code-block:: python

 >>> P=gelib.SO3bipart.randn(1,2,3,4)
 >>> P
 <GElib::SO3bipart(b=1,l1=2,l2=3,n=4)>
 >>> print(P)
  Channel 0:
  [ (-1.23974,0) (1.3828,0) (-1.66043,0) (0.097221,0) (0.584898,0) (0.74589,0) (-0.546571,0) ]
  [ (-0.370271,0) (-1.50279,0) (-0.764676,0) (1.32256,0) (-0.696964,0) (-1.96886,0) (-0.274068,0) ]
  [ (0.0431933,0) (-0.257851,0) (-1.13769,0) (-1.39814,0) (-1.2589,0) (-0.149277,0) (-0.322037,0) ]
  [ (-1.21275,0) (-0.187871,0) (-1.62807,0) (-1.20183,0) (-0.42954,0) (0.630166,0) (-1.1945,0) ]
  [ (0.680457,0) (-0.37048,0) (-0.0893479,0) (1.1648,0) (-0.653697,0) (0.321597,0) (-1.36411,0) ]

  Channel 1:
  [ (-0.407472,0) (0.0523187,0) (-0.688081,0) (-0.89237,0) (-0.660558,0) (-1.75177,0) (-0.0384917,0) ]
  [ (-1.12408,0) (0.570759,0) (0.250854,0) (1.93468,0) (0.537104,0) (0.354178,0) (0.005616,0) ]
  [ (-1.96668,0) (-0.391737,0) (-1.22027,0) (-0.477463,0) (0.259477,0) (-1.3338,0) (-0.380621,0) ]
  [ (-0.100699,0) (-0.0230505,0) (-0.250657,0) (-0.399454,0) (-2.20967,0) (0.137796,0) (1.06918,0) ]
  [ (1.40633,0) (0.0266631,0) (2.04214,0) (-0.915378,0) (-0.645572,0) (-0.406172,0) (1.01046,0) ]

  Channel 2:
  [ (1.61201,0) (-0.904146,0) (0.0757219,0) (-0.228782,0) (0.534755,0) (-0.965146,0) (0.194947,0) ]
  [ (1.73664,0) (-0.929941,0) (-0.188164,0) (1.25244,0) (0.694816,0) (-0.455262,0) (-1.77286,0) ]
  [ (-0.480737,0) (2.69588,0) (0.111152,0) (0.643125,0) (-1.6247,0) (-1.44352,0) (0.593568,0) ]
  [ (0.468701,0) (-0.302782,0) (0.658802,0) (-0.727057,0) (-1.22569,0) (0.674001,0) (-1.2115,0) ]
  [ (-0.31774,0) (0.592888,0) (0.200541,0) (-0.566838,0) (0.471302,0) (-1.41157,0) (0.588378,0) ]

  Channel 3:
  [ (0.399771,0) (1.87065,0) (1.47339,0) (1.16493,0) (-0.607787,0) (-0.474282,0) (-0.485144,0) ]
  [ (0.882195,0) (-0.934988,0) (-1.51315,0) (1.0417,0) (0.541231,0) (0.377994,0) (0.519691,0) ]
  [ (-1.83641,0) (1.6585,0) (-0.672931,0) (1.37519,0) (-0.996947,0) (0.65806,0) (1.05796,0) ]
  [ (0.819091,0) (-0.999364,0) (-0.973458,0) (0.43853,0) (0.73464,0) (-0.281158,0) (-2.1947,0) ]
  [ (0.123568,0) (-0.165017,0) (0.277807,0) (-0.419928,0) (1.52415,0) (-1.49311,0) (0.515642,0) ]

``SO3bipart`` supports many of the same operations as the ``SO3part`` class, except that instead of 
taking ``CGproduct``s, we can apply a ``CGtransform`` to contract the two SO(3)-covariant 
indices into a single one. The result is an ``SO3part`` object. 
For example, the following computes the :math:`\ell=1` component of such a contraction:

.. code-block:: python

 >>> Q=gelib.CGtransform(P,1)
 >>> Q
 <GElib::SO3part(b=1,l=1,n=4)>
 >>> print(Q)
 [ (-0.213503,0) (-0.250336,0) (-0.276431,0) (-0.0712574,0) ]
 [ (0.544488,0) (-1.03109,0) (-0.46173,0) (0.662361,0) ]
 [ (0.510107,0) (0.355053,0) (-0.0549618,0) (-1.01385,0) ]

``SO3bipartArr`` is the arrayed version of ``SO3bipart``, similar to ``SO3partArr``. 

 